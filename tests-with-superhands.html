<html class="a-fullscreen">

<head>
    <title>Oculus</title>
    <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui,viewport-fit=cover">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link href="assets/css/main.css" rel="stylesheet">

    <!-- the aframe standard library -->
    <script src="https://aframe.io/releases/0.9.2/aframe.js"></script>

    <!-- adding physics -->
    <script src="lib/aframe/aframe-physics-system.min.js"></script>
    <script src="lib/aframe/aframe-event-set-component.min.js"></script>
    <script src="lib/aframe/aframe-physics-extras.min.js"></script>
    <script src="lib/aframe/aframe-environment-component.min.js"></script>

    <!-- superhands code -->
    <script src="https://cdn.rawgit.com/donmccurdy/aframe-extras/v4.1.2/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/super-hands@3.0.0/dist/super-hands.min.js"></script>
</head>

<body>
    <a-scene physics>
        <!-- common assets -->
        <a-assets>
            <!--
            the oculus controller (hands-left, hands-right) MIXIN
            enables interacting between controler an objects

            using 'superhands'
            using a 'sphere-collider' for superhands  
        
            hover & drag-drop won't have any obvious effect without some additional event handlers or components.

            colliderEvent: collision                -> makes objects grabbable
            colliderEvent: raycaster-intersection:  -> ???
            -->
            <a-mixin physics-collider phase-shift id="interaction" static-body="shape: sphere; sphereRadius: 0.02;"
                sphere-collider="objects: #box, #sphere" collision-filter laser-controls line raycaster="
                showLine: true; 
                objects: .cube" collision-filter="collisionForces: false" super-hands="
                colliderEvent: collisions;
                colliderEventProperty: els;
                colliderEndEvent: collisions;
                colliderEndEventProperty: clearedEls;

                grabStartButtons: gripdown, mousedown;
                grabEndButtons: gripup, mouseup;

                startButtons: triggerdown; 
                endButtons: triggerup;">
            </a-mixin>
        </a-assets>

        <!-- camera, controller and the log box in a rig -->
        <a-entity id="rig" position="0 0 0">
            <!-- - - - - - - - - - - -->
            <a-entity camera="active: true" look-controls wasd-controls></a-entity>

            <!-- 
                    the oculus controller (hands-left, hands-right)
                    using the interaction mixin (assets)
                    -->
            <a-entity mixin="interaction" hand-controls="left">
                <!-- <a-box width="0.05" height="0.05" depth="1" position="0 0 -0.55" opacity="0.1" transparency="true"
                    static-body glow="scale: 1.3; color: #FF00FF;"></a-box> -->
            </a-entity>
            <a-entity mixin="interaction" hand-controls="right" aabb-collider="objects: #box;">
                <!-- <a-box width="0.05" height="0.05" depth="1" position="0 0 -0.55" opacity="0.1" transparency="true"
                    static-body glow="scale: 1.3; color: #FF00FF;"></a-box> -->
            </a-entity>

            <!--
                    the log
                    -->
            <a-text id="text" position="-1.45 1 -1.5"
                value="Sedative posuere consectetur est at lobortis. Cras justo odio, dapibus ac facilisis in, egestas eget quam. Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum."
                color="rgb(220,220,220)" width="1.2" height="0.7" font="https://cdn.aframe.io/fonts/Exo2SemiBold.fnt">
            </a-text>
            <!-- - - - - - - - - - - -->
        </a-entity>

        <!-- naviation -->
        <!-- <a-entity id="navigation"> -->
        <!-- - - - - - - - - - - -->
        <!-- <a-link visualAspectEnabled="false" href="step-001-1.html" title="a page"
                image="../assets/figures/step001.jpg" size="0.25" position="-1 1 -10" on="click" peekMode="true">
            </a-link> -->
        <!-- <a-link visualAspectEnabled="false" href="step-001-1.html" title="another page"
                image="../assets/figures/step001.jpg" size="0.25" position="1 1 -10" on="click" peekMode="true"> -->
        <!-- </a-link> -->
        <!-- - - - - - - - - - - -->
        <!-- </a-entity> -->


        <!-- 
                2 simple objects
                the id's are registered in the sphere-sollider object list
                this enabled grabbing and scaling 
            -->
        <a-box id="box" color="orange" width="0.5" height="1" depth="0.5" position="0 2 -1" rotation="0 0 0" hoverable
            grabbable stretchable draggable droppable dynamic-body="mass:1; boundingBox: 0.5 1 0.5;"></a-box>

        <a-sphere id="sphere" color="orange" radius="0.25" position="0.5 2 -0.5" rotation="0 0 0" hoverable grabbable
            stretchable draggable droppable dynamic-body></a-sphere>

        <!-- a ground box to avoid deep tumbles -->
        <a-box id="earth" width="50" height="0.1" depth="50" position="0 0 0"
            material="src: assets/figures/wood-planks.jpg; repeat:50 25;" static-body>
        </a-box>

        <!-- group for the moving plane -->
        <a-entity id="group" position="0 0 0"
            animation__1="property: rotation; dir: alternate; dur: 20000; easing: easeInOutElastic; loop: true; from: 0 -180 0; to: 0 180 0;"
            animation__2="property: position; dir: alternate; dur: 20000; easing: linear; loop: true; from: -10 0 0; to: -10 0.5 -10;">
            <!-- - - - - - - - - - - -->
            <a-box id="ground" width="10" height="0.1" depth="10" position="0 0 0"
                material="src: assets/figures/wood-planks.jpg; repeat:10 5;" static-body>
            </a-box>
            <a-box id="fence-left" material="src: assets/figures/beton.jpg; repeat:10 1;" width="0.5" height="0.25"
                depth="10.5" position="-5 0.125 0" static-body>
            </a-box>
            <a-box id="fence-right" material="src: assets/figures/beton.jpg; repeat:10 1;" width="0.5" height="0.25"
                depth="10.5" position="5 0.125 0" static-body>
            </a-box>
            <a-box id="fence-front" material="src: assets/figures/beton.jpg; repeat:4 1;" width="10.5" height="0.25"
                depth="0.5" position="0 0.125 -5" static-body>
            </a-box>
            <a-box id="fence-back" material="src: assets/figures/beton.jpg; repeat:4 1;" width="10.5" height="0.25"
                depth="0.5" position="0 0.125 5" static-body>
            </a-box>
            <!-- - - - - - - - - - - -->
        </a-entity>

        <!-- 
        an external obj-file
        it can be grabbed by dynamic-body="shape: sphere; mass: 2; sphereRadius: 0.5; halfExtents: 0.5 0.5 0.5;"
        @see https://github.com/donmccurdy/aframe-physics-system
        -->
        <!-- <a-obj-model id="object" scale="1 1 1" position="0.1 2 -2.5" hoverable grabbable stretchable draggable droppable
            obj-model="obj: assets/models/room.obj; mtl: assets/models/room.mtl" dynamic-body>
        </a-obj-model> -->


        <!-- <a-entity log="message: Hello, Metaverse!"></a-entity> -->

        <a-light type="spot" angle="85" distance="12" position="-1 8 0" color="hsla(0, 90%, 80%)" target="#box">
        </a-light>
        <a-light type="spot" angle="85" distance="12" position="0 8 0" color="hsla(120, 90%, 80%)" target="#sphere">
        </a-light>
        <a-light type="spot" angle="85" distance="12" position="1 8 0" color="hsla(240, 90%, 80%)" target="#rig">
        </a-light>
        <a-light type="spot" angle="15" intensity="0.25" position="4 8 0" color="hsla(0, 50%, 100%)" target="#group"
            shadowMapHeight="1024" shadowMapWidth="1024">
        </a-light>
    </a-scene>
    <script>
        (function () {
            'use strict';
            // - - - - - - - - - -
            window.onload = function () {
                // - - - - -
                // DECLARATION
                let inworld = {};
                inworld.data = ['initializing ...'];

                /** INVENTING AN INWORLD OBJECT
                 * @desc the inworld objet is a container for inworld function,
                 *       i.e. a log() that can be seen in a textframe.
                 *       It uses a limited array of messages. (10 so far)
                 * @version 1.0.0
                 * @author Michael
                 *
                 * An inworld log function
                 * @param {string} message any text string to set into a inworls textframe
                 * @return none
                 */
                inworld.log = function (message) {
                    let
                        _message = message || undefined,
                        _messages = '',
                        _limit = 10,
                        _text = document.querySelector('#text') || undefined;

                    if (_message === undefined) return false;
                    if (_text === undefined) return false;

                    inworld.data.push(_message);

                    if (inworld.data.length > _limit) inworld.data.shift();

                    for (let i = 0; i < inworld.data.length; i++) {
                        _messages += '>  ' + inworld.data[i] + '\n';
                    }

                    _text.setAttribute('value', _messages);
                };


                // // Uncomment to see a inworld.log() demo
                // // - - - - - - - - - -
                // let
                //     counter = 0,
                //     demo = setInterval(function () {
                //         inworld.log('I can count to ' + counter++ + '. Yeah!!');
                //         if (counter > 50) clearInterval(demo);
                //     }, 5000);
                // // - - - - - - - - - -

                /**
                 * Implement AABB collision detection for entities with a mesh.
                 * (https://en.wikipedia.org/wiki/Minimum_bounding_box#Axis-aligned_minimum_bounding_box)
                 * It sets the specified state on the intersected entities.
                 *
                 * @property {string} objects - Selector of the entities to test for collision.
                 * @property {string} state - State to set on collided entities.
                 *
                 */
                AFRAME.registerComponent('aabb-collider', {
                    schema: {
                        objects: {
                            default: ''
                        },
                        state: {
                            default: 'collided'
                        }
                    },

                    init: function () {
                        this.els = [];
                        this.collisions = [];
                        this.elMax = new THREE.Vector3();
                        this.elMin = new THREE.Vector3();

                        inworld.log('AABB Collider initialized.');
                    },

                    /**
                     * Update list of entities to test for collision.
                     */
                    update: function () {
                        var data = this.data;
                        var objectEls;

                        // Push entities into list of els to intersect.
                        if (data.objects) {
                            objectEls = this.el.sceneEl.querySelectorAll(data.objects);
                        } else {
                            // If objects not defined, intersect with everything.
                            objectEls = this.el.sceneEl.children;
                        }
                        // Convert from NodeList to Array
                        this.els = Array.prototype.slice.call(objectEls);
                    },

                    tick: (function () {
                        var boundingBox = new THREE.Box3();
                        return function () {
                            var collisions = [];
                            var el = this.el;
                            var mesh = el.getObject3D('mesh');
                            var self = this;
                            // No mesh, no collisions
                            if (!mesh) {
                                return;
                            }
                            // Update the bounding box to account for rotations and
                            // position changes.
                            updateBoundingBox();
                            // Update collisions.
                            this.els.forEach(intersect);
                            // Emit events.
                            collisions.forEach(handleHit);
                            // No collisions.
                            if (collisions.length === 0) {
                                self.el.emit('hit', {
                                    el: null
                                });
                            }
                            // Updated the state of the elements that are not intersected anymore.
                            this.collisions.filter(function (el) {
                                return collisions.indexOf(el) === -1;
                            }).forEach(function removeState(el) {
                                el.removeState(self.data.state);
                            });
                            // Store new collisions
                            this.collisions = collisions;

                            // AABB collision detection
                            function intersect(el) {
                                var intersected;
                                var mesh = el.getObject3D('mesh');
                                var elMin;
                                var elMax;
                                if (!mesh) {
                                    return;
                                }
                                boundingBox.setFromObject(mesh);
                                elMin = boundingBox.min;
                                elMax = boundingBox.max;
                                // Bounding boxes are always aligned with the world coordinate system.
                                // The collision test checks for the conditions where cubes intersect.
                                // It's an extension to 3 dimensions of this approach (with the condition negated)
                                // https://www.youtube.com/watch?v=ghqD3e37R7E
                                intersected = (self.elMin.x <= elMax.x && self.elMax.x >=
                                        elMin.x) &&
                                    (self.elMin.y <= elMax.y && self.elMax.y >= elMin.y) &&
                                    (self.elMin.z <= elMax.z && self.elMax.z >= elMin.z);
                                if (!intersected) {
                                    return;
                                }
                                collisions.push(el);
                            }

                            function handleHit(hitEl) {
                                hitEl.emit('hit');
                                hitEl.addState(self.data.state);
                                self.el.emit('hit', {
                                    el: hitEl
                                });
                            }

                            function updateBoundingBox() {
                                boundingBox.setFromObject(mesh);
                                self.elMin.copy(boundingBox.min);
                                self.elMax.copy(boundingBox.max);
                            }
                        };
                    })()
                });
                // - - - - - - - - - -
                // CONTROLS
                inworld.log('ready.');

                // REGISTER AFRAME COMPONENTS
                // AFRAME.registerComponent('log', {
                //     schema: {
                //         message: {
                //             type: 'string',
                //             default: 'Hello, World!'
                //         }
                //     },
                //     init: function () {
                //         console.log(this.data.message);
                //     }
                // });

                // AFRAME.registerComponent('box', {
                //     // the object properties
                //     // example is a box
                //     // the schema property 'width' can be called as 'this.data.width'
                //     schema: {
                //         width: {
                //             type: 'number',
                //             default: 1
                //         },
                //         height: {
                //             type: 'number',
                //             default: 1
                //         },
                //         depth: {
                //             type: 'number',
                //             default: 1
                //         },
                //         color: {
                //             type: 'color',
                //             default: 'steelblue'
                //         }
                //     },
                //     // the object behaviour after compiling 
                //     init: function () {
                //         var data = this.data; // references the schema properties
                //         var el = this.el; //     references the a-frame-entity

                //         console.log(el);
                //         console.log(data);

                //         // Create geometry.
                //         this.geometry = new THREE.BoxBufferGeometry(data.width, data.height, data.depth);

                //         // Create material.
                //         this.material = new THREE.MeshStandardMaterial({
                //             color: data.color
                //         });

                //         // Create mesh.
                //         this.mesh = new THREE.Mesh(this.geometry, this.material);

                //         // Set mesh on entity.
                //         el.setObject3D('mesh', this.mesh);
                //     },
                //     update: function () {
                //         var data = this.data;
                //         var el = this.el;

                //         // If `oldData` is empty, then this means we're in the initialization process.
                //         // No need to update.
                //         if (Object.keys(oldData).length === 0) {
                //             return;
                //         }

                //         // Geometry-related properties changed. Update the geometry.
                //         if (data.width !== oldData.width ||
                //             data.height !== oldData.height ||
                //             data.depth !== oldData.depth) {
                //             el.getObject3D('mesh').geometry = new THREE.BoxBufferGeometry(data.width, data
                //                 .height,
                //                 data.depth);
                //         }

                //         // Material-related properties changed. Update the material.
                //         if (data.color !== oldData.color) {
                //             el.getObject3D('mesh').material.color = new THREE.Color(data.color);
                //         }

                //     },
                //     remove: function () {
                //         this.el.removeObject3D('mesh');
                //     }
                // })



                // let box = document.querySelector('#box').addEventListener('collide', function (event) {
                //     text.setAttribute('value', event.target);
                // })
                // - - - - -
            };
            // - - - - - - - - - -
        })();
    </script>
</body>

</html>